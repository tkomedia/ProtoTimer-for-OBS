<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Stage Timer Rundown for OBS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use a monospaced font for the timer numbers for clarity */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@700&display=swap');
        .timer-font {
            font-family: 'Space Mono', monospace;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .main-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        /* Hide the scrollbar for a cleaner look in the Browser Source */
        body::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col p-4">

    <!-- Timer Display Area -->
    <div id="timer-display" class="relative flex-grow flex items-center justify-center transition-colors duration-300">
        
        <!-- Logo/Title Indicator (Top Left Corner) -->
        <div id="logo-title" class="absolute top-8 left-8 text-xl md:text-3xl font-medium text-white">
            <span class="font-bold text-indigo-400">ProtoTimer</span> <span class="text-gray-400 font-normal text-lg md:text-xl">by Terrence Ozaki</span>
        </div>

        <!-- Total Runtime Indicator (Top Right Corner) -->
        <div id="total-runtime" class="absolute top-8 right-8 text-xl md:text-3xl font-medium text-gray-400">
            Total: 00:00
        </div>
        
        <div class="main-display">
            <!-- Timer Index Indicator (Top Center) -->
            <div id="timer-index" class="text-xl md:text-3xl font-medium mb-4 text-indigo-400">
                Timer 1 of 1
            </div>
            <div id="timer-value" class="timer-font text-8xl md:text-[14rem] lg:text-[18rem] font-bold tracking-tight">05:00</div>
        </div>
    </div>

    <!-- Configuration Panel -->
    <div id="control-panel" class="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-4xl mx-auto space-y-6">
        <h2 class="text-xl font-semibold text-center text-indigo-400">OBS-WebSocket Rundown Setup (Max 10 Timers)</h2>

        <div id="status-message" class="text-center p-2 rounded-lg font-medium bg-gray-700">
            Status: <span class="text-yellow-400">Awaiting Connection...</span>
        </div>

        <!-- Timer Duration Rundown Inputs -->
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4 p-4 border border-gray-700 rounded-lg bg-gray-700/50">
            <!-- Inputs will be generated here by loop -->
            <script>
                // Generate 10 duration input fields dynamically
                const inputsContainer = document.querySelector('.grid.grid-cols-2.md\\:grid-cols-5');
                for (let i = 1; i <= 10; i++) {
                    // Default the first timer to '5:00' to hint at the M:SS format
                    const defaultVal = (i === 1) ? '5:00' : ''; 
                    const label = document.createElement('label');
                    label.className = 'block';
                    label.innerHTML = `
                        <span class="text-xs font-medium text-gray-400">Timer ${i} (M:SS or Min)</span>
                        <input type="text" id="duration-input-${i}" value="${defaultVal}" class="mt-1 w-full p-2 border border-gray-600 bg-gray-800 rounded-lg text-lg focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="e.g., 1:30 or 1.5">
                    `;
                    inputsContainer.appendChild(label);
                }
            </script>
        </div>

        <!-- Connection and Password -->
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 pt-4 border-t border-gray-700">
            <label class="block flex-grow">
                <span class="text-sm font-medium text-gray-400">OBS-WebSocket Password (Leave blank if none)</span>
                <input type="password" id="password-input" class="mt-1 w-full p-2 border border-gray-600 bg-gray-700 rounded-lg text-lg focus:ring-indigo-500 focus:border-indigo-500 transition">
            </label>

            <button id="connect-button" class="mt-4 md:mt-0 w-full md:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-md hover:shadow-lg disabled:opacity-50" onclick="connectToObs()">
                Connect to OBS
            </button>
        </div>
    </div>

    <script>
        // Constants for WebSocket
        const OBS_WEBSOCKET_URL = 'ws://127.0.0.1:4455';
        
        // DOM Elements
        const timerValueEl = document.getElementById('timer-value');
        const timerIndexEl = document.getElementById('timer-index');
        const totalRuntimeEl = document.getElementById('total-runtime');
        const statusMessageEl = document.getElementById('status-message');
        const passwordInputEl = document.getElementById('password-input');

        // State Variables
        let ws = null;
        let countdownInterval = null;
        
        // Rundown State
        let timerRundown = [];     // Stores all valid durations in MS
        let totalRundownDurationMs = 0; // Stores the sum of all valid durations
        let currentTimerIndex = 0; // Index (0-9) of the currently running timer
        let remainingTimeMs = 0;
        let lastUpdateTime = Date.now();
        let isRunning = false;
        let isAwaitingAuthentication = false;

        // --- Utility Functions ---

        /** Formats milliseconds into MM:SS string. */
        function formatTime(ms) {
            const totalSeconds = Math.round(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        /**
         * Implements the OBS-WebSocket V5 authentication handshake.
         * Calculates SHA256(SHA256(password + salt) + challenge).
         */
        async function getAuthResponse(salt, challenge, password) {
            const encoder = new TextEncoder();
            
            // Step 1: Compute SHA256(password + salt)
            const passwordSha = await crypto.subtle.digest(
                'SHA-256', 
                encoder.encode(password + salt)
            );
            
            // Convert ArrayBuffer to Hex String
            const passwordHash = Array.from(new Uint8Array(passwordSha))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');

            // Step 2: Compute SHA256(hash_from_step_1 + challenge)
            const authResponseSha = await crypto.subtle.digest(
                'SHA-256',
                encoder.encode(passwordHash + challenge)
            );
            
            // Convert ArrayBuffer to Hex String (Final Response)
            const authResponse = Array.from(new Uint8Array(authResponseSha))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
                
            return authResponse.toUpperCase();
        }

        /** Updates the display and color based on remaining time. */
        function updateDisplay() {
            if (remainingTimeMs < 0) remainingTimeMs = 0;
            
            timerValueEl.textContent = formatTime(remainingTimeMs);

            // Update Total Runtime
            totalRuntimeEl.textContent = `Total: ${formatTime(totalRundownDurationMs)}`;

            // Update Rundown Index
            const totalTimers = timerRundown.length;
            if (totalTimers > 0) {
                // Display "Timer X of Y"
                timerIndexEl.textContent = `Timer ${currentTimerIndex + 1} of ${totalTimers}`;
            } else {
                timerIndexEl.textContent = 'Setup Required';
            }

            // Conditional Coloring
            if (remainingTimeMs <= 60000 && remainingTimeMs > 0) { // Below 1 minute (60,000 ms)
                timerValueEl.classList.add('text-red-500');
                timerValueEl.classList.remove('text-white');
            } else if (remainingTimeMs === 0 && !isRunning) {
                timerValueEl.classList.add('text-gray-500'); // Faded grey when finished
                timerValueEl.classList.remove('text-white', 'text-red-500');
            } else {
                timerValueEl.classList.add('text-white');
                timerValueEl.classList.remove('text-red-500', 'text-gray-500');
            }
        }

        // --- Timer Control Logic ---

        function startTimer() {
            if (isRunning) return;
            if (timerRundown.length === 0) {
                updateStatus('ERROR: No valid timers defined.', 'text-red-500');
                return;
            }
            
            isRunning = true;
            lastUpdateTime = Date.now();
            updateStatus(`Rundown started. Running Timer ${currentTimerIndex + 1}.`, 'text-green-400');

            if (countdownInterval) clearInterval(countdownInterval);

            countdownInterval = setInterval(() => {
                if (!isRunning) return;

                const now = Date.now();
                const delta = now - lastUpdateTime;
                lastUpdateTime = now;

                remainingTimeMs -= delta;

                if (remainingTimeMs <= 0) {
                    if (currentTimerIndex < timerRundown.length - 1) {
                        // Auto-advance to the next timer
                        currentTimerIndex++;
                        remainingTimeMs = timerRundown[currentTimerIndex];
                        lastUpdateTime = Date.now(); // Reset update time for next timer
                        updateStatus(`Timer ${currentTimerIndex + 1} starting.`, 'text-orange-400');
                    } else {
                        // Last timer finished
                        stopTimer();
                        remainingTimeMs = 0;
                        updateStatus('Rundown finished!', 'text-green-400');
                    }
                }
                updateDisplay();
            }, 100); // Check every 100ms for smoother visual updates
        }

        function stopTimer() {
            isRunning = false;
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function resetTimer() {
            stopTimer(); // Ensure interval is cleared

            // 1. Read all duration inputs and build the rundown array
            timerRundown = [];
            totalRundownDurationMs = 0; // RESET
            
            for (let i = 1; i <= 10; i++) {
                const input = document.getElementById(`duration-input-${i}`);
                const value = input.value.trim(); // Get input as a string
                
                let durationMs = 0;

                if (value) {
                    if (value.includes(':')) {
                        // Handle M:SS format (e.g., "1:30")
                        const parts = value.split(':');
                        const minutes = parseInt(parts[0]) || 0;
                        const seconds = parseInt(parts[1]) || 0;
                        // Ensure seconds don't exceed 59 for a clean calculation
                        const effectiveSeconds = Math.min(seconds, 59); 
                        durationMs = (minutes * 60 + effectiveSeconds) * 1000;

                    } else {
                        // Handle decimal/whole minutes format (e.g., "5" or "1.5")
                        const minutes = parseFloat(value) || 0;
                        durationMs = minutes * 60 * 1000;
                    }
                }
                
                // Only include timers that have a positive duration
                if (durationMs > 0) {
                    timerRundown.push(durationMs);
                    totalRundownDurationMs += durationMs; // Accumulate total runtime
                }
            }

            // 2. Reset the state to the beginning of the rundown
            currentTimerIndex = 0;
            if (timerRundown.length > 0) {
                 remainingTimeMs = timerRundown[currentTimerIndex];
            } else {
                 remainingTimeMs = 0;
            }

            updateDisplay();
            updateStatus(`Rundown prepared: ${timerRundown.length} timers ready.`, 'text-indigo-400');
        }

        // --- OBS WebSocket Handlers ---

        function updateStatus(message, colorClass = 'text-yellow-400') {
            statusMessageEl.innerHTML = `Status: <span class="${colorClass}">${message}</span>`;
        }

        async function connectToObs() { // Made async for auth hashing
            if (ws) {
                ws.close();
            }
            
            // First, run a reset to read the latest durations before connecting
            resetTimer(); 
            
            const password = passwordInputEl.value;

            // Important: Set this flag before opening the connection if a password is provided
            isAwaitingAuthentication = !!password; 

            ws = new WebSocket(OBS_WEBSOCKET_URL);

            ws.onopen = () => {
                updateStatus('Connected to OBS. Awaiting Handshake...', 'text-yellow-400');
            };

            ws.onmessage = async (event) => { // Made async for auth hashing
                const data = JSON.parse(event.data);
                
                // Op Code 0: Hello from Server (First message, contains auth info)
                if (data.op === 0) {
                    const auth = data.d.authentication;
                    
                    if (auth) {
                        // Authentication is required
                        if (!password) {
                            updateStatus('ERROR: Authentication required but password not entered.', 'text-red-500');
                            ws.close();
                            return;
                        }
                        
                        try {
                            // This is the line that sometimes fails due to security restrictions on local files
                            const authResponse = await getAuthResponse(auth.salt, auth.challenge, password);
                            
                            // --- DEBUGGING OUTPUT ---
                            console.log("OBS Auth Salt:", auth.salt);
                            console.log("OBS Auth Challenge:", auth.challenge);
                            console.log("OBS Password entered:", password);
                            console.log("Calculated Auth Response:", authResponse);
                            // --- END DEBUGGING OUTPUT ---

                            const identifyPayload = {
                                op: 1, // Op code for Identify
                                d: {
                                    rpcVersion: 1,
                                    authentication: authResponse, // Send calculated response
                                    eventSubscriptions: 1 << 6 // Subscribe to RecordStateChanged event
                                }
                            };
                            ws.send(JSON.stringify(identifyPayload));
                            updateStatus('Sent authentication response...', 'text-orange-400');

                        } catch (e) {
                            console.error("Auth Hashing Failed:", e);
                            updateStatus('Authentication Hashing Failed (Check Console). Is your browser current?', 'text-red-500');
                            ws.close();
                        }
                    } else {
                        // Authentication is NOT required
                        const identifyPayload = {
                            op: 1, // Op code for Identify
                            d: {
                                rpcVersion: 1,
                                eventSubscriptions: 1 << 6 
                            }
                        };
                        ws.send(JSON.stringify(identifyPayload));
                        updateStatus('Authentication not required. Identifying...', 'text-orange-400');
                    }
                }
                
                // Op Code 2: Identified (Authentication successful)
                if (data.op === 2) {
                    isAwaitingAuthentication = false;
                    updateStatus('Authenticated successfully. Ready! Start recording to begin.', 'text-green-500');
                }

                // Op Code 3: Re-Identify (Used on connection disruption/resumption, though rare here)
                if (data.op === 3) {
                    // We don't need to do anything special here since we are subscribing on Identify
                }

                // Op Code 5: Event
                if (data.op === 5 && data.d.eventType === 'RecordStateChanged') {
                    const outputState = data.d.eventData.outputState;

                    if (outputState === 'OBS_WEBSOCKET_OUTPUT_STARTED') {
                        // Recording has started
                        resetTimer(); // Reset to the start of the rundown
                        startTimer();
                        updateStatus('Recording STARTED. Rundown Active.', 'text-red-500');
                    } else if (outputState === 'OBS_WEBSOCKET_OUTPUT_STOPPED') {
                        // Recording has stopped
                        stopTimer();
                        updateStatus('Recording STOPPED. Timer Reset.', 'text-yellow-500');
                    }
                }
            };

            ws.onerror = (error) => {
                updateStatus('Connection Error. Check console/port.', 'text-red-500');
                console.error("WebSocket Error:", error);
            };

            ws.onclose = () => {
                if (isAwaitingAuthentication) {
                    // This specific message is only shown if we know we tried to authenticate 
                    // and the connection closed immediately after.
                    updateStatus('Authentication Failed. Check password (use simple characters!) and OBS settings.', 'text-red-500');
                } else {
                    // Generic disconnection message
                    updateStatus('Disconnected from OBS.', 'text-red-500');
                }
                stopTimer();
            };
        }

        // Initialize on load
        window.onload = () => {
            // Add event listeners to all duration inputs to trigger a reset/re-read when changed
            for (let i = 1; i <= 10; i++) {
                const input = document.getElementById(`duration-input-${i}`);
                if (input) {
                    input.addEventListener('change', resetTimer);
                    // Also listen for keyup to refresh total time dynamically
                    input.addEventListener('keyup', resetTimer);
                }
            }
            // Initial read and display of the default timer (5:00)
            resetTimer(); 
        }
    </script>
</body>
</html>
